#!/usr/bin/env python3

from enum import IntEnum
import inspect
import os
from pathlib import Path
import re
import subprocess
import sys
from textwrap import indent
from typing import Callable, Iterable, NamedTuple, Optional, TypeVar

if __package__ is None or __package__ == "":
    root_dir = os.path.normpath(os.path.join(os.path.abspath(os.path.dirname(__file__)), '../..'))
    sys.path.insert(0, root_dir)
    __package__ = os.path.dirname(os.path.relpath(__file__, root_dir)).replace('/', '.')

from ..utils.argument_parser import ArgumentParser

# Add the Python root directory (fusion-engine-client/python/) to the import search path to enable FusionEngine imports
# if this application is being run directly out of the repository and is not installed as a pip package.
ROOT_DIR = Path(__file__).absolute().parents[2]
sys.path.insert(0, str(ROOT_DIR))

# Text in source files to identify sections to update with generated code.
CPP_CONSTANTS_START_TEXT = 'Start Autogenerated Constants'
CPP_CONSTANTS_STOP_TEXT = 'Stop Autogenerated Constants'
START_TEXT = 'Start Autogenerated Types'
STOP_TEXT = 'Stop Autogenerated Types'

CPP_SIGNAL_DEFS_PATH = ROOT_DIR.parent / 'src/point_one/fusion_engine/messages/signal_defs.h'
PYTHON_SIGNAL_DEFS_PATH = ROOT_DIR / 'fusion_engine_client/messages/signal_defs.py'
CPP_INDENT = '  '
PYTHON_INDENT = '    '


def update_generated_code_in_file(path: Path, generated_code: str, start_text: str = START_TEXT,
                                  stop_text: str = STOP_TEXT):
    '''!
    Replace the text in the file at `path` between `start_text` and `stop_text` with `generated_code`.
    '''
    in_generated = False
    current_file_contents = open(path).readlines()

    with open(path, 'w') as fd:
        for line in current_file_contents:
            if start_text in line:
                in_generated = True
                fd.write(line)
                fd.write(generated_code)
            elif stop_text in line:
                in_generated = False

            if not in_generated:
                fd.write(line)


# This import is from the file with generated code. If a previous run generated invalid code, this import will fail with
# whatever syntax error was introduced. This check will clear the generated code so hopefully re-running won't
# experience the same error.
try:
    from fusion_engine_client.messages.signal_defs import (
        BeiDouSignalName, GNSSComponent, FrequencyBand, GalileoSignalName,
        GLONASSSignalName, GNSSSignalType, GPSSignalName, QZSSSignalName,
        SatelliteType, SBASSignalName, SignalName, _get_gnss_enum_bit_packing,
        _get_pretty_gnss_signal_type, _GNSSSignalPartType,
        pretty_print_gnss_enum, to_signal_val)
except:
    print('Unable to load fusion_engine_client.messages.signal_defs. This may be a result of a previous code '
          'generation run producing code with syntax errors.')
    print('Clearing generated code. Try rerunning.')
    update_generated_code_in_file(PYTHON_SIGNAL_DEFS_PATH, PYTHON_INDENT + 'UNKNOWN = 0\n')
    sys.exit(1)

SIGNAL_PART_ENUM_LIST = [
    SatelliteType,
    FrequencyBand,
    SignalName,
    GNSSComponent,
]

ENUM_LIST = [
    SatelliteType,
    FrequencyBand,
    GNSSComponent,
    GPSSignalName,
    GLONASSSignalName,
    GalileoSignalName,
    BeiDouSignalName,
    SBASSignalName,
    QZSSSignalName,
    GNSSSignalType]

############################# Common GNSSSignalType Generation #############################

def get_generated_code_in_file(path: Path, start_text: str = START_TEXT,
                               stop_text: str = STOP_TEXT) -> str:
    '''!
    Return the text in the file at `path` between `start_text` and `stop_text`.
    '''
    current_file_contents = open(path).readlines()
    generated_lines = []
    in_generated = False
    for line in current_file_contents:
        if start_text in line:
            in_generated = True
        elif stop_text in line:
            break
        elif in_generated:
            generated_lines.append(line)
    return ''.join(generated_lines)


class GNSSSignalTypeDefinition(NamedTuple):
    satellite_type: SatelliteType
    frequency_band: FrequencyBand
    signal_name: SignalName
    gnss_component: GNSSComponent = GNSSComponent.COMBINED


# THIS IS THE CANONICAL DEFINITION OF GNSS SIGNAL TYPES.
GNSS_SIGNAL_TYPE_DEFINITIONS = {
    'GPS_L1CA': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L1, GPSSignalName.L1CA),
    'GPS_L1P': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L1, GPSSignalName.L1P),
    'GPS_L1C': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L1, GPSSignalName.L1C),
    'GPS_L1C_D': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L1, GPSSignalName.L1C, GNSSComponent.DATA),
    'GPS_L1C_P': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L1, GPSSignalName.L1C, GNSSComponent.PILOT),
    'GPS_L2C': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L2, GPSSignalName.L2C),
    'GPS_L2C_M': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L2, GPSSignalName.L2C, GNSSComponent.DATA),
    'GPS_L2C_L': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L2, GPSSignalName.L2C, GNSSComponent.PILOT),
    'GPS_L2P': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L2, GPSSignalName.L2P),
    'GPS_L5': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L5, GPSSignalName.L5),
    'GPS_L5_I': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L5, GPSSignalName.L5, GNSSComponent.DATA),
    'GPS_L5_Q': GNSSSignalTypeDefinition(SatelliteType.GPS, FrequencyBand.L5, GPSSignalName.L5, GNSSComponent.PILOT),
    'GLONASS_L1CA': GNSSSignalTypeDefinition(SatelliteType.GLONASS, FrequencyBand.L1, GLONASSSignalName.L1CA),
    'GLONASS_L1P': GNSSSignalTypeDefinition(SatelliteType.GLONASS, FrequencyBand.L1, GLONASSSignalName.L1P),
    'GLONASS_L2CA': GNSSSignalTypeDefinition(SatelliteType.GLONASS, FrequencyBand.L2, GLONASSSignalName.L2CA),
    'GLONASS_L2P': GNSSSignalTypeDefinition(SatelliteType.GLONASS, FrequencyBand.L2, GLONASSSignalName.L2P),
    'GALILEO_E1A': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L1, GalileoSignalName.E1A),
    'GALILEO_E1BC': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L1, GalileoSignalName.E1BC),
    'GALILEO_E1B': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L1, GalileoSignalName.E1BC, GNSSComponent.DATA),
    'GALILEO_E1C': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L1, GalileoSignalName.E1BC, GNSSComponent.PILOT),
    'GALILEO_E5B': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L2, GalileoSignalName.E5B),
    'GALILEO_E5B_I': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L2, GalileoSignalName.E5B, GNSSComponent.DATA),
    'GALILEO_E5B_Q': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L2, GalileoSignalName.E5B, GNSSComponent.PILOT),
    'GALILEO_E5A': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L5, GalileoSignalName.E5A),
    'GALILEO_E5A_I': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L5, GalileoSignalName.E5A, GNSSComponent.DATA),
    'GALILEO_E5A_Q': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L5, GalileoSignalName.E5A, GNSSComponent.PILOT),
    'GALILEO_E6A': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L6, GalileoSignalName.E6A),
    'GALILEO_E6BC': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L6, GalileoSignalName.E6BC),
    'GALILEO_E6B': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L6, GalileoSignalName.E6BC, GNSSComponent.DATA),
    'GALILEO_E6C': GNSSSignalTypeDefinition(SatelliteType.GALILEO, FrequencyBand.L6, GalileoSignalName.E6BC, GNSSComponent.PILOT),
    'BEIDOU_B1I': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L1, BeiDouSignalName.B1I),
    'BEIDOU_B1C': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L1, BeiDouSignalName.B1C),
    'BEIDOU_B1C_D': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L1, BeiDouSignalName.B1C, GNSSComponent.DATA),
    'BEIDOU_B1C_P': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L1, BeiDouSignalName.B1C, GNSSComponent.PILOT),
    'BEIDOU_B2I': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L2, BeiDouSignalName.B2I),
    'BEIDOU_B2B': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L2, BeiDouSignalName.B2B),
    'BEIDOU_B2A': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L5, BeiDouSignalName.B2A),
    'BEIDOU_B2A_D': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L5, BeiDouSignalName.B2A, GNSSComponent.DATA),
    'BEIDOU_B2A_P': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L5, BeiDouSignalName.B2A, GNSSComponent.PILOT),
    'BEIDOU_B3I': GNSSSignalTypeDefinition(SatelliteType.BEIDOU, FrequencyBand.L6, BeiDouSignalName.B3I),
    'SBAS_L1CA': GNSSSignalTypeDefinition(SatelliteType.SBAS, FrequencyBand.L1, SBASSignalName.L1CA),
    'SBAS_L5': GNSSSignalTypeDefinition(SatelliteType.SBAS, FrequencyBand.L5, SBASSignalName.L5),
    'SBAS_L5_I': GNSSSignalTypeDefinition(SatelliteType.SBAS, FrequencyBand.L5, SBASSignalName.L5, GNSSComponent.DATA),
    'SBAS_L5_Q': GNSSSignalTypeDefinition(SatelliteType.SBAS, FrequencyBand.L5, SBASSignalName.L5, GNSSComponent.PILOT),
    'QZSS_L1CA': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L1, QZSSSignalName.L1CA),
    'QZSS_L1C': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L1, QZSSSignalName.L1C),
    'QZSS_L1C_D': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L1, QZSSSignalName.L1C, GNSSComponent.DATA),
    'QZSS_L1C_P': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L1, QZSSSignalName.L1C, GNSSComponent.PILOT),
    'QZSS_L2C': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L2, QZSSSignalName.L2C),
    'QZSS_L2C_M': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L2, QZSSSignalName.L2C, GNSSComponent.DATA),
    'QZSS_L2C_L': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L2, QZSSSignalName.L2C, GNSSComponent.PILOT),
    'QZSS_L5': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L5, QZSSSignalName.L5),
    'QZSS_L5_I': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L5, QZSSSignalName.L5, GNSSComponent.DATA),
    'QZSS_L5_Q': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L5, QZSSSignalName.L5, GNSSComponent.PILOT),
    'QZSS_L6': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L2, QZSSSignalName.L6),
    'QZSS_L6_M': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L2, QZSSSignalName.L6, GNSSComponent.DATA),
    'QZSS_L6_L': GNSSSignalTypeDefinition(SatelliteType.QZSS, FrequencyBand.L2, QZSSSignalName.L6, GNSSComponent.PILOT),
}


def gnss_signal_type_value_comment(name: str, definition: GNSSSignalTypeDefinition) -> str:
    '''!
    Get the comment string associated with a GNSSSignalType enum value.

    For example:
    GPS_L1CA -> "GPS L1 C/A: 4096 (0x1000)"
    BEIDOU_B1C_D -> "BeiDou B1C-D (Data): 20485 (0x5005)"
    '''
    comment = _get_pretty_gnss_signal_type(
        name,
        definition.satellite_type,
        definition.signal_name,
        definition.gnss_component)
    value = to_signal_val(*definition)
    comment += f': {value} (0x{value:04X})'
    return comment


def find_nth(haystack: str, needle: str, n: int) -> int:
    start = haystack.find(needle)
    while start >= 0 and n > 1:
        start = haystack.find(needle, start + len(needle))
        n -= 1
    return start


def generate_gnss_signal_type_enum_values_source(comment_char: str, banner: Callable[[str], str],
                                                 value: Callable[[GNSSSignalTypeDefinition], str], use_commas=False) -> str:
    '''!
    Generate the body of the GNSSSignalType enum. Parameters are set to different values for generating either Python or
    C++ code.
    '''
    comma_str = ',' if use_commas else ''
    code = f'UNKNOWN = 0{comma_str}\n'

    # The type ignores here are because our custom enum type doesn't report the right type when iterated over.
    for sv_type in SatelliteType:
        sv_matches = {k: v for k, v in GNSS_SIGNAL_TYPE_DEFINITIONS.items() if v.satellite_type == sv_type}
        if len(sv_matches) > 0:
            code += banner(pretty_print_gnss_enum(sv_type))  # type: ignore
        for freq_band in FrequencyBand:
            freq_matches = {k: v for k, v in sv_matches.items() if v.frequency_band == freq_band}
            if len(freq_matches) > 0:
                code += f'\n{(comment_char * 2)} {pretty_print_gnss_enum(freq_band)} Band\n\n'  # type: ignore
            for name, match in freq_matches.items():
                code += f'{(comment_char * 3)} {gnss_signal_type_value_comment(name, match)}\n'
                comma_str = ',' if use_commas else ''
                declaration_str = f'{name} = {value(match)}{comma_str}\n'
                # This is to decrease the line length by putting the arguments for the value onto multiple lines
                # ```
                # FOO(_1, _2, _3)
                # vs
                # FOO(_1, _2,
                #     _3)
                param_start = declaration_str.index('(')
                line_split = find_nth(declaration_str, ',', 2)
                code += declaration_str[:line_split + 1] + '\n'
                code += ' ' * param_start + declaration_str[line_split + 1:]

    return code


############################# Python Generation #############################


def python_banner_str(msg: str) -> str:
    '''!
    Generate the string for a banner comment in Python.
    '''
    BANNER = '#' * 76
    return f'\n{BANNER}\n## {msg}\n{BANNER}\n'


def python_signal_enum_value_str(signal_def: GNSSSignalTypeDefinition) -> str:
    '''!
    Generate the string for the value assigned to a GNSSSignalType enum entry in Python.
    '''
    enum_names = tuple(e.name for e in signal_def)
    FORMAT_STR = 'to_signal_val(SatelliteType.{}, FrequencyBand.{}, ' + \
        type(signal_def.signal_name).__name__ + '.{}, GNSSComponent.{})'
    return FORMAT_STR.format(*enum_names)


############################# CPP Generation #############################

def cpp_multiline_comment(contents: str) -> str:
    '''!
    Generate the string for a multiline C++ comment.
    '''
    lines = [(f' * {line}' if line else ' *') + '\n' for line in contents.split('\n')]
    return '/**\n' + ''.join(lines) + ' */'


def cpp_banner_str(msg: str) -> str:
    '''!
    Generate the string for a banner comment in C++.
    '''
    BANNER = '/' * 78
    return f'\n{BANNER}\n// {msg}\n{BANNER}\n'


def cpp_signal_enum_value_str(signal_def: GNSSSignalTypeDefinition) -> str:
    '''!
    Generate the string for the value assigned to a GNSSSignalType enum entry in C++.
    '''
    enum_names = tuple(e.name for e in signal_def)
    FORMAT_STR = 'ToSignalVal(SatelliteType::{}, FrequencyBand::{}, ' + \
        type(signal_def.signal_name).__name__ + '::{}, GNSSComponent::{})'
    return FORMAT_STR.format(*enum_names)


class EnumValue(NamedTuple):
    comment: str
    value: str


_PYTHON_COMMENT_RE = re.compile(r'\s*#+\s*(.*)')
_PYTHON_ENUM_VALUE_RE = re.compile(r'\s*([A-Z0-9_a-z]+) = (.+)')


E = TypeVar('E', bound=IntEnum)


def get_enum_values(enum_type: type[E]) -> Optional[dict[E, EnumValue]]:
    '''!
    Parse contents from Python enums to be used to generate C++ enums.
    '''
    source_lines = inspect.getsourcelines(enum_type)
    comment = []
    values: dict[E, EnumValue] = {}
    enum_value_names = {e.name for e in enum_type}
    for line in source_lines[0]:
        comment_match = _PYTHON_COMMENT_RE.match(line)
        if comment_match:
            comment_line = comment_match.group(1)
            # Skip empty lines at start of comment (used for doxygen formatting).
            if len(comment) != 0 or len(comment_line.strip()) != 0:
                comment.append(comment_match.group(1))
            continue

        value_match = _PYTHON_ENUM_VALUE_RE.match(line)
        if value_match:
            value_name = value_match.group(1)
            value_def = value_match.group(2)
            if value_name in enum_value_names:
                values[enum_type[value_name]] = EnumValue('\n'.join(comment), value_def)
            else:
                print(f'Matched invalid enum value {value_name} while parsing {enum_type}')
                return None

        comment = []

    for val in enum_type:
        if val not in values:
            print(f'Missed enum value {val.name} while parsing {enum_type}')
            return None

    return values


def generate_cpp_enum_declaration(name: str, comment: Optional[str], int_type: str, values_code: str) -> str:
    code = ''
    if comment:
        code += cpp_multiline_comment(comment) + '\n'
    code += f'''\
enum class {name} : {int_type} {{
{indent(values_code, CPP_INDENT)}}};'''
    return code


def strip_python_comment(comment: Optional[str]) -> str:
    '''!
    Remove leading hashes and space from python comment.
    If the comment is `None` return an empty string.
    '''
    if comment is None:
        return ''
    _PYTHON_COMMENT_PREFIX_RE = re.compile(r'^\s*#+ ?', re.MULTILINE)
    return re.sub(_PYTHON_COMMENT_PREFIX_RE, '', comment).strip()


def generate_cpp_enum_from_python(enum_type: type[IntEnum], int_type='uint8_t') -> str:
    '''!
    Generate a the full C++ enum source code from an existing Python enum.
    '''
    values = get_enum_values(enum_type)
    assert values
    comment = strip_python_comment(inspect.getcomments(enum_type))
    values_code = ''
    for key, value in values.items():
        if value.comment:
            values_code += ''.join(f'// {line.strip()}\n' for line in value.comment.split('\n'))
        values_code += f'{key} = {value.value},\n'

    return generate_cpp_enum_declaration(enum_type.__name__, comment, int_type, values_code)


def generate_cpp_to_string(enum_type: type[_GNSSSignalPartType], pretty_values: dict[str, str]) -> str:
    '''!
    Generate the C++ source code for the enum `to_string`, `operator<<` and `ToPrettyString` functions.
    '''
    name = enum_type.__name__
    to_string_cases = '\n\n'.join(f'''\
case {name}::{k}:
  return "{k}";''' for k in pretty_values.keys())

    to_pretty_string_cases = '\n\n'.join(f'''\
case {name}::{k}:
  return "{p}";''' for k, p in pretty_values.items())  # type: ignore

    return f'''\
/**
 * @brief Get a string representation of the @ref {name} enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string({name} type) {{
  switch (type) {{
{indent(to_string_cases, '    ')}
  }}
  return "INVALID";
}}

/**
 * @copydoc to_string()
 */
inline const char* ToString({name} type) {{ return to_string(type); }}

/**
 * @brief @ref {name} stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, {name} type) {{
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}}

/**
 * @brief Get a human-friendly string for the specified @ref {name}.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString({name} type) {{
  switch (type) {{
{indent(to_pretty_string_cases, '    ')}
  }}
  return "Invalid";
}}'''


def get_gnss_enum_cpp_name(enum_type: type[_GNSSSignalPartType]) -> str:
   '''!
   Convert a Python signal part type to a C++ constant prefix: `SatelliteType` -> "SATELLITE_TYPE".
   '''
   name = enum_type.__name__
   # Reference: https://stackoverflow.com/a/29920015
   def _camel_case_split(identifier):
        matches = re.finditer('.+?(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|$)', identifier)
        return [m.group(0) for m in matches]
   cpp_name = ('_'.join(m.upper() for m in _camel_case_split(name)))
   return cpp_name


def generate_cpp_get_part(enum_type: type[_GNSSSignalPartType]) -> str:
    '''!
    Generate the C++ source code for getting the enum value of a component type of @ref GNSSSignalType. An example
    function would be `GetSatelliteTypePart`.
    '''
    name = enum_type.__name__
    # Note: All signal name enums (GPSSignalName, etc.) use the same SIGNAL_NAME_SHIFT/BITS with no leading name (GPS,
    # etc.).
    cpp_prefix = get_gnss_enum_cpp_name(SignalName if issubclass(enum_type, SignalName) else enum_type)
    return f'''\
/**
 * @brief Extract the @ref {name} enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref {name} will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC {name} Get{name}(GNSSSignalType signal_type) {{
  return static_cast<{name}>(
      static_cast<uint8_t>((static_cast<uint16_t>(signal_type) >> {cpp_prefix}_SHIFT) & ((1 << {cpp_prefix}_BITS) - 1)));
}}'''


def generate_cpp_gnss_signal_type() -> str:
    '''!
    Generate the C++ source code for @ref GNSSSignalType. Unlike other enums, this is generated from @ref
    GNSS_SIGNAL_TYPE_DEFINITIONS rather then from parsing the Python enum source code.
    '''
    # Turn formatting of to prevent formatter from modifying line breaks.
    values_code = '// clang-format off\n'
    values_code += generate_gnss_signal_type_enum_values_source(
        '/', cpp_banner_str, cpp_signal_enum_value_str, use_commas=True)
    values_code += '// clang-format on\n'
    comment = strip_python_comment(inspect.getcomments(GNSSSignalType))
    return generate_cpp_enum_declaration('GNSSSignalType', comment, 'uint16_t', values_code)


def generate_cpp_constants_defs() -> str:
    '''!
    Generate the top constants portion C++ source code (shift and size constants).
    '''
    def _make_constants(enum_type: type[_GNSSSignalPartType]):
        cpp_prefix = get_gnss_enum_cpp_name(enum_type)
        bit_packing = _get_gnss_enum_bit_packing(enum_type)  # type: ignore
        return f'''\
constexpr unsigned {cpp_prefix}_SHIFT = {bit_packing.bit_offset};
constexpr unsigned {cpp_prefix}_BITS = {bit_packing.bit_len};
'''
    return ''.join(_make_constants(enum_type) for enum_type in SIGNAL_PART_ENUM_LIST)


def generate_cpp_signal_defs() -> str:
    '''!
    Generate all the generated C++ source code. This includes enum definitions and helper functions.
    '''
    def _make_functions(enum_type: type[_GNSSSignalPartType]):
        if enum_type == GNSSSignalType:
            pretty_values = {
                k: _get_pretty_gnss_signal_type(
                    k,
                    v.satellite_type,
                    v.signal_name,
                    v.gnss_component) for k,
                v in GNSS_SIGNAL_TYPE_DEFINITIONS.items()}
            pretty_values['UNKNOWN'] = 'Unknown'
            return generate_cpp_gnss_signal_type() + '\n\n' + generate_cpp_to_string(enum_type, pretty_values) + '\n\n'
        else:
            pretty_values = {k.name: pretty_print_gnss_enum(k) for k in enum_type}  # type: ignore
            return generate_cpp_enum_from_python(enum_type) + '\n\n' \
                + generate_cpp_to_string(enum_type, pretty_values) + '\n\n' \
                + generate_cpp_get_part(enum_type) + '\n\n'

    return ''.join(_make_functions(enum_type) for enum_type in ENUM_LIST)


############################# Entry Point #############################

def update_python_code(check_only=False) -> bool:
    """!
    @brief Generate source code contents for @ref GNSSSignalType.

    If `not check_only` then replace the contents in fusion_engine_client/messages/signal_defs.py with the newly
    generated values.

    @param check_only If `True`, only return whether the generated contents differ from what's currently save and do not
           update the file contents.

    @return `True` if newly generated code differed from the previously generated code.
    """
    generated_python_code = '\n' + generate_gnss_signal_type_enum_values_source(
        '#', python_banner_str, python_signal_enum_value_str) + '\n'
    generated_python_code = indent(generated_python_code, PYTHON_INDENT)
    differs = get_generated_code_in_file(PYTHON_SIGNAL_DEFS_PATH) != generated_python_code
    if differs:
        if check_only:
                print('Python file out of date.')
        else:
            print('Updating generated Python code.')
            update_generated_code_in_file(PYTHON_SIGNAL_DEFS_PATH, generated_python_code)
    else:
        print('Generated Python code matches current file contents.')
    return differs


def format_cpp_code(cpp_source: str) -> str:
    result = subprocess.run(['clang-format', '-style=file'], cwd=os.path.dirname(os.path.abspath(__file__)),
                            input=cpp_source, capture_output=True, encoding='utf-8')
    if result.returncode == 0:
        return result.stdout
    else:
        raise RuntimeError(f'clang-format exited with code {result.returncode}: {result.stderr}')


def update_cpp_code(check_only=False) -> bool:
    """!
    @brief Generate source code contents for @ref SatelliteType, @ref FrequencyBand, @ref GNSSComponent, @ref
           GPSSignalName, @ref GLONASSSignalName, @ref BeiDouSignalName, @ref GalileoSignalName, @ref SBASSignalName,
           @ref QZSSSignalName, and @ref GNSSSignalType.

    If `not check_only` then replace the contents in src/point_one/fusion_engine/messages/signal_defs.h with the newly
    generated values.

    @param check_only If `True`, only return whether the generated contents differ from what's currently save and do not
           update the file contents.

    @return `True` if newly generated code differed from the previously generated code.
    """
    # The code we extract from the existing C++ file has been formatted with clang-format. We also need to format the
    # generated code so the != check works, and so the updated C++ file is formatted correctly.
    generated_constants_cpp_code = '\n' + format_cpp_code(generate_cpp_constants_defs()) + '\n'
    current_constants_cpp_code = get_generated_code_in_file(CPP_SIGNAL_DEFS_PATH,
                                                            start_text=CPP_CONSTANTS_START_TEXT,
                                                            stop_text=CPP_CONSTANTS_STOP_TEXT)
    constants_differs = generated_constants_cpp_code != current_constants_cpp_code

    generated_signals_cpp_code = '\n' + format_cpp_code(generate_cpp_signal_defs()) + '\n'
    current_signals_cpp_code = get_generated_code_in_file(CPP_SIGNAL_DEFS_PATH)
    signals_differs = generated_signals_cpp_code != current_signals_cpp_code

    differs = constants_differs or signals_differs
    if differs:
        if check_only:
                print('C++ file out of date.')
        else:
            print('Updating generated C++ code.')
            update_generated_code_in_file(CPP_SIGNAL_DEFS_PATH, generated_constants_cpp_code,
                                          start_text=CPP_CONSTANTS_START_TEXT, stop_text=CPP_CONSTANTS_STOP_TEXT)
            update_generated_code_in_file(CPP_SIGNAL_DEFS_PATH, generated_signals_cpp_code)
    else:
        print('Generated C++ code matches current file contents.')
    return differs


if __name__ == '__main__':
    parser = ArgumentParser(description="""\
Update the auto-generated source code after making changes to the signal
definitions in signal_defs.py.
""")

    parser.add_argument(
        '--check-only', action='store_true',
        help="Check if any of the source files are out of date but do not update them. The application will exit with "
             "a non-zero exit code if one or more source files is outdated.")

    options = parser.parse_args()

    differs = False
    differs |= update_python_code(check_only=options.check_only)
    differs |= update_cpp_code(check_only=options.check_only)

    if options.check_only and differs:
        sys.exit(1)
