/**************************************************************************/ /**
 * @brief GNSS signal and frequency type definitions.
 ******************************************************************************/

#pragma once

#include <cstdint>

#include "point_one/fusion_engine/common/portability.h"

namespace point_one {
namespace fusion_engine {
namespace messages {

// Enum forward declarations.
enum class SatelliteType : uint8_t;
enum class FrequencyBand : uint8_t;
enum class GNSSComponent : uint8_t;
enum class GPSSignalName : uint8_t;
enum class GLONASSSignalName : uint8_t;
enum class BeiDouSignalName : uint8_t;
enum class GalileoSignalName : uint8_t;
enum class SBASSignalName : uint8_t;
enum class QZSSSignalName : uint8_t;
enum class GNSSSignalType : uint16_t;

// > Start Autogenerated Constants (See python/fusion_engine_client/messages/signal_def_gen.py)

constexpr unsigned SATELLITE_TYPE_SHIFT = 12;
constexpr unsigned SATELLITE_TYPE_BITS = 4;
constexpr unsigned FREQUENCY_BAND_SHIFT = 6;
constexpr unsigned FREQUENCY_BAND_BITS = 4;
constexpr unsigned SIGNAL_NAME_SHIFT = 2;
constexpr unsigned SIGNAL_NAME_BITS = 3;
constexpr unsigned GNSS_COMPONENT_SHIFT = 0;
constexpr unsigned GNSS_COMPONENT_BITS = 2;

// < Stop Autogenerated Constants (See python/fusion_engine_client/messages/signal_def_gen.py)

/**
 * @brief Compile time check for whether a type is one of the SignalName enums.
 *
 * @tparam T The type to check.
 *
 * @return `true`, if T is a SignalName enum. Return `false` otherwise.
 */
template <typename T>
P1_CONSTEXPR_FUNC bool IsSignalNameType() {
  return std::is_same<T, GPSSignalName>::value ||
         std::is_same<T, GLONASSSignalName>::value ||
         std::is_same<T, BeiDouSignalName>::value ||
         std::is_same<T, GalileoSignalName>::value ||
         std::is_same<T, SBASSignalName>::value ||
         std::is_same<T, QZSSSignalName>::value;
}

/**
 * @defgroup gnss_enum_types Enums and helper functions for describing GNSS
 *           satellites and their signals.
 * @ingroup enum_definitions
 *
 * @section gnss_enums_to_bitmasks
 * The GNSS signal enumerations can be used in bitmasks, such as listing
 * enabled/disabled signal types. In this case, the bit mask corresponds with
 * the enum value as follows: `mask = (1 << bit value)`
 *
 * For example, for GPS signal types, to enable L1 C/A (enum value of 0) and L5
 * (enum value of 5) signals, a mask of 0x21 would be used, calculated as shown:
 * 0x21 (0b0010 0001) = 0x1 (0b0000 0001) | 0x20 (0b0010 0000)
 *
 * @{
 */

/**
 * @brief Create a @ref GNSSSignalType from the enums that it's made up from.
 *
 * @tparam SignalName The type of the `SignalName` (see @ref IsSignalNameType())
 *         that is included in this signal type.
 * @param sv_type The constellation of this signal.
 * @param freq_band The frequency band of this signal.
 * @param signal_name The type of signal for the constellation. For example, if
 *        the `sv_type` is @ref SatelliteType::GPS, than this will specify which
 *        of the @ref GPSSignalName this signal is.
 * @param component The components of this signal.
 *
 * @return A @ref GNSSSignalType value made from combining the parameters.
 */
// Note: This function intentionally does not use P1_CONSTEXPR_FUNC. It must be
// constexpr to be used within the GNSSSignalType enum definition below.
// Instead, where multi-line constexpr functions are not supported (i.e., before
// C++14), the static_assert is disabled to allow the function to compile.
template <typename SignalName>
constexpr uint16_t ToSignalVal(SatelliteType sv_type, FrequencyBand freq_band,
                               SignalName signal_name,
                               GNSSComponent component) {
#if P1_HAVE_MULTILINE_CONSTEXPR_FUNC
  static_assert(IsSignalNameType<SignalName>(),
                "signal_name must be one of the *SignalName types.");
#endif // P1_HAVE_MULTILINE_CONSTEXPR_FUNC
  return static_cast<uint8_t>(sv_type) << SATELLITE_TYPE_SHIFT |
         static_cast<uint8_t>(freq_band) << FREQUENCY_BAND_SHIFT |
         static_cast<uint8_t>(signal_name) << SIGNAL_NAME_SHIFT |
         static_cast<uint8_t>(component) << GNSS_COMPONENT_SHIFT;
}

/**
 * @copydoc ToSignalVal()
 *
 * @warning If the combination of values is not defined in @ref GNSSSignalType,
 *          the returned value will not be valid.
 */
template <typename SignalName>
P1_CONSTEXPR_FUNC GNSSSignalType ToSignalType(SatelliteType sv_type,
                                              FrequencyBand freq_band,
                                              SignalName signal_name,
                                              GNSSComponent component) {
  return static_cast<GNSSSignalType>(
      ToSignalVal(sv_type, freq_band, signal_name, component));
}

// > Start Autogenerated Types (See python/fusion_engine_client/messages/signal_def_gen.py)

/**
 * @brief System/constellation type definitions.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 4 bits so no values above 15 are allowed.
 */
enum class SatelliteType : uint8_t {
  UNKNOWN = 0,
  GPS = 1,
  GLONASS = 2,
  LEO = 3,
  GALILEO = 4,
  BEIDOU = 5,
  QZSS = 6,
  MIXED = 7,
  SBAS = 8,
  IRNSS = 9,
};

/**
 * @brief Get a string representation of the @ref SatelliteType enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(SatelliteType type) {
  switch (type) {
    case SatelliteType::UNKNOWN:
      return "UNKNOWN";

    case SatelliteType::GPS:
      return "GPS";

    case SatelliteType::GLONASS:
      return "GLONASS";

    case SatelliteType::LEO:
      return "LEO";

    case SatelliteType::GALILEO:
      return "GALILEO";

    case SatelliteType::BEIDOU:
      return "BEIDOU";

    case SatelliteType::QZSS:
      return "QZSS";

    case SatelliteType::MIXED:
      return "MIXED";

    case SatelliteType::SBAS:
      return "SBAS";

    case SatelliteType::IRNSS:
      return "IRNSS";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(SatelliteType type) { return to_string(type); }

/**
 * @brief @ref SatelliteType stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, SatelliteType type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref SatelliteType.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(SatelliteType type) {
  switch (type) {
    case SatelliteType::UNKNOWN:
      return "UNKNOWN";

    case SatelliteType::GPS:
      return "GPS";

    case SatelliteType::GLONASS:
      return "GLONASS";

    case SatelliteType::LEO:
      return "LEO";

    case SatelliteType::GALILEO:
      return "Galileo";

    case SatelliteType::BEIDOU:
      return "BeiDou";

    case SatelliteType::QZSS:
      return "QZSS";

    case SatelliteType::MIXED:
      return "MIXED";

    case SatelliteType::SBAS:
      return "SBAS";

    case SatelliteType::IRNSS:
      return "IRNSS";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref SatelliteType enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref SatelliteType will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC SatelliteType GetSatelliteType(GNSSSignalType signal_type) {
  return static_cast<SatelliteType>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> SATELLITE_TYPE_SHIFT) &
      ((1 << SATELLITE_TYPE_BITS) - 1)));
}

/**
 * @brief GNSS frequency band definitions.
 *
 * A frequency band generally includes multiple GNSS carrier frequencies and
 * signal types, which can usually be captured by a single antenna element.
 * For example, an L1 antenna typically has sufficient bandwidth to capture
 * signals on the BeiDou B1I (1561.098 MHz), GPS L1 (1575.42 MHz), and GLONASS G1
 * (1602.0 MHz) frequencies.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 4 bits so no values about 15 are allowed.
 */
enum class FrequencyBand : uint8_t {
  // ~L1 = 1561.098 MHz (B1) -> 1602.0 (G1)
  // Includes: GPS L1, Galileo E1, BeiDou B1I (and B1C == L1), GLONASS G1
  L1 = 0,
  // ~L2 = 1202.025 MHz (G3) -> 1248.06 (G2)
  // Includes: GPS L2, Galileo E5b, BeiDou B2I, GLONASS G2 & G3
  L2 = 1,
  // ~L5 = 1176.45 MHz (L5)
  // Includes: GPS L5, Galileo E5a, BeiDou B2a, IRNSS L5
  L5 = 2,
  // ~L6 = 1268.52 MHz (B3) -> 1278.75 MHz (L6)
  // Includes: Galileo E6, BeiDou B3, QZSS L6
  L6 = 3,
  // ~(L1 - L2) = 296.67 MHz (QZSS L6) -> 373.395 MHz (G3)
  L1_L2_WIDE_LANE = 4,
  // ~(L1 - L5) = 398.97 MHz (L5)
  L1_L5_WIDE_LANE = 5,
  // S band 2.0 -> 4.0 GHz
  // IRNSS S band is 2492.028 MHz
  S = 6,
};

/**
 * @brief Get a string representation of the @ref FrequencyBand enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(FrequencyBand type) {
  switch (type) {
    case FrequencyBand::L1:
      return "L1";

    case FrequencyBand::L2:
      return "L2";

    case FrequencyBand::L5:
      return "L5";

    case FrequencyBand::L6:
      return "L6";

    case FrequencyBand::L1_L2_WIDE_LANE:
      return "L1_L2_WIDE_LANE";

    case FrequencyBand::L1_L5_WIDE_LANE:
      return "L1_L5_WIDE_LANE";

    case FrequencyBand::S:
      return "S";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(FrequencyBand type) { return to_string(type); }

/**
 * @brief @ref FrequencyBand stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, FrequencyBand type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref FrequencyBand.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(FrequencyBand type) {
  switch (type) {
    case FrequencyBand::L1:
      return "L1";

    case FrequencyBand::L2:
      return "L2";

    case FrequencyBand::L5:
      return "L5";

    case FrequencyBand::L6:
      return "L6";

    case FrequencyBand::L1_L2_WIDE_LANE:
      return "L1-L2 Wide-Lane";

    case FrequencyBand::L1_L5_WIDE_LANE:
      return "L1-L5 Wide-Lane";

    case FrequencyBand::S:
      return "S";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref FrequencyBand enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref FrequencyBand will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC FrequencyBand GetFrequencyBand(GNSSSignalType signal_type) {
  return static_cast<FrequencyBand>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> FREQUENCY_BAND_SHIFT) &
      ((1 << FREQUENCY_BAND_BITS) - 1)));
}

/**
 * @brief The component being tracked for signals that have separate data and
 *        pilot components.
 *
 * This needs to be packed into 2 bits so no values above 3 are allowed.
 */
enum class GNSSComponent : uint8_t {
  COMBINED = 0,
  DATA = 1,
  PILOT = 2,
};

/**
 * @brief Get a string representation of the @ref GNSSComponent enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(GNSSComponent type) {
  switch (type) {
    case GNSSComponent::COMBINED:
      return "COMBINED";

    case GNSSComponent::DATA:
      return "DATA";

    case GNSSComponent::PILOT:
      return "PILOT";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(GNSSComponent type) { return to_string(type); }

/**
 * @brief @ref GNSSComponent stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, GNSSComponent type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref GNSSComponent.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(GNSSComponent type) {
  switch (type) {
    case GNSSComponent::COMBINED:
      return "Combined";

    case GNSSComponent::DATA:
      return "Data";

    case GNSSComponent::PILOT:
      return "Pilot";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref GNSSComponent enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref GNSSComponent will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC GNSSComponent GetGNSSComponent(GNSSSignalType signal_type) {
  return static_cast<GNSSComponent>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> GNSS_COMPONENT_SHIFT) &
      ((1 << GNSS_COMPONENT_BITS) - 1)));
}

/**
 * @brief The name of a signal from a GPS satellite.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 3 bits so no values above 7 are allowed.
 */
enum class GPSSignalName : uint8_t {
  L1CA = 0,
  L1P = 1,
  L1C = 2,
  L2C = 3,
  L2P = 4,
  L5 = 5,
};

/**
 * @brief Get a string representation of the @ref GPSSignalName enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(GPSSignalName type) {
  switch (type) {
    case GPSSignalName::L1CA:
      return "L1CA";

    case GPSSignalName::L1P:
      return "L1P";

    case GPSSignalName::L1C:
      return "L1C";

    case GPSSignalName::L2C:
      return "L2C";

    case GPSSignalName::L2P:
      return "L2P";

    case GPSSignalName::L5:
      return "L5";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(GPSSignalName type) { return to_string(type); }

/**
 * @brief @ref GPSSignalName stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, GPSSignalName type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref GPSSignalName.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(GPSSignalName type) {
  switch (type) {
    case GPSSignalName::L1CA:
      return "C/A";

    case GPSSignalName::L1P:
      return "L1 P(Y)";

    case GPSSignalName::L1C:
      return "L1C";

    case GPSSignalName::L2C:
      return "L2C";

    case GPSSignalName::L2P:
      return "L2 P(Y)";

    case GPSSignalName::L5:
      return "L5";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref GPSSignalName enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref GPSSignalName will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC GPSSignalName GetGPSSignalName(GNSSSignalType signal_type) {
  return static_cast<GPSSignalName>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> SIGNAL_NAME_SHIFT) &
      ((1 << SIGNAL_NAME_BITS) - 1)));
}

/**
 * @brief The name of a signal from a GLONASS satellite.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 3 bits so no values above 7 are allowed.
 */
enum class GLONASSSignalName : uint8_t {
  L1CA = 0,
  L1P = 1,
  L2CA = 2,
  L2P = 3,
};

/**
 * @brief Get a string representation of the @ref GLONASSSignalName enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(GLONASSSignalName type) {
  switch (type) {
    case GLONASSSignalName::L1CA:
      return "L1CA";

    case GLONASSSignalName::L1P:
      return "L1P";

    case GLONASSSignalName::L2CA:
      return "L2CA";

    case GLONASSSignalName::L2P:
      return "L2P";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(GLONASSSignalName type) { return to_string(type); }

/**
 * @brief @ref GLONASSSignalName stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, GLONASSSignalName type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref GLONASSSignalName.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(GLONASSSignalName type) {
  switch (type) {
    case GLONASSSignalName::L1CA:
      return "L1 C/A";

    case GLONASSSignalName::L1P:
      return "L1P";

    case GLONASSSignalName::L2CA:
      return "L2 C/A";

    case GLONASSSignalName::L2P:
      return "L2P";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref GLONASSSignalName enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref GLONASSSignalName will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC GLONASSSignalName
GetGLONASSSignalName(GNSSSignalType signal_type) {
  return static_cast<GLONASSSignalName>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> SIGNAL_NAME_SHIFT) &
      ((1 << SIGNAL_NAME_BITS) - 1)));
}

/**
 * @brief The name of a signal from a Galileo satellite.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 3 bits so no values above 7 are allowed.
 */
enum class GalileoSignalName : uint8_t {
  E1A = 0,
  E1BC = 1,
  E5A = 2,
  E5B = 3,
  E6A = 4,
  E6BC = 5,
};

/**
 * @brief Get a string representation of the @ref GalileoSignalName enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(GalileoSignalName type) {
  switch (type) {
    case GalileoSignalName::E1A:
      return "E1A";

    case GalileoSignalName::E1BC:
      return "E1BC";

    case GalileoSignalName::E5A:
      return "E5A";

    case GalileoSignalName::E5B:
      return "E5B";

    case GalileoSignalName::E6A:
      return "E6A";

    case GalileoSignalName::E6BC:
      return "E6BC";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(GalileoSignalName type) { return to_string(type); }

/**
 * @brief @ref GalileoSignalName stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, GalileoSignalName type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref GalileoSignalName.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(GalileoSignalName type) {
  switch (type) {
    case GalileoSignalName::E1A:
      return "E1-A";

    case GalileoSignalName::E1BC:
      return "E1-B/C";

    case GalileoSignalName::E5A:
      return "E5a";

    case GalileoSignalName::E5B:
      return "E5b";

    case GalileoSignalName::E6A:
      return "E6-A";

    case GalileoSignalName::E6BC:
      return "E6-B/C";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref GalileoSignalName enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref GalileoSignalName will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC GalileoSignalName
GetGalileoSignalName(GNSSSignalType signal_type) {
  return static_cast<GalileoSignalName>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> SIGNAL_NAME_SHIFT) &
      ((1 << SIGNAL_NAME_BITS) - 1)));
}

/**
 * @brief The name of a signal from a BeiDou satellite.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 3 bits so no values above 7 are allowed.
 */
enum class BeiDouSignalName : uint8_t {
  B1I = 0,
  B1C = 1,
  B2I = 2,
  B2B = 3,
  B2A = 4,
  B3I = 5,
};

/**
 * @brief Get a string representation of the @ref BeiDouSignalName enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(BeiDouSignalName type) {
  switch (type) {
    case BeiDouSignalName::B1I:
      return "B1I";

    case BeiDouSignalName::B1C:
      return "B1C";

    case BeiDouSignalName::B2I:
      return "B2I";

    case BeiDouSignalName::B2B:
      return "B2B";

    case BeiDouSignalName::B2A:
      return "B2A";

    case BeiDouSignalName::B3I:
      return "B3I";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(BeiDouSignalName type) { return to_string(type); }

/**
 * @brief @ref BeiDouSignalName stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, BeiDouSignalName type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref BeiDouSignalName.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(BeiDouSignalName type) {
  switch (type) {
    case BeiDouSignalName::B1I:
      return "B1I";

    case BeiDouSignalName::B1C:
      return "B1C";

    case BeiDouSignalName::B2I:
      return "B2I";

    case BeiDouSignalName::B2B:
      return "B2b";

    case BeiDouSignalName::B2A:
      return "B2a";

    case BeiDouSignalName::B3I:
      return "B3I";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref BeiDouSignalName enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref BeiDouSignalName will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC BeiDouSignalName
GetBeiDouSignalName(GNSSSignalType signal_type) {
  return static_cast<BeiDouSignalName>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> SIGNAL_NAME_SHIFT) &
      ((1 << SIGNAL_NAME_BITS) - 1)));
}

/**
 * @brief The name of a signal from a SBAS satellite.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 3 bits so no values above 7 are allowed.
 */
enum class SBASSignalName : uint8_t {
  L1CA = 0,
  L5 = 1,
};

/**
 * @brief Get a string representation of the @ref SBASSignalName enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(SBASSignalName type) {
  switch (type) {
    case SBASSignalName::L1CA:
      return "L1CA";

    case SBASSignalName::L5:
      return "L5";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(SBASSignalName type) { return to_string(type); }

/**
 * @brief @ref SBASSignalName stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, SBASSignalName type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref SBASSignalName.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(SBASSignalName type) {
  switch (type) {
    case SBASSignalName::L1CA:
      return "C/A";

    case SBASSignalName::L5:
      return "L5";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref SBASSignalName enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref SBASSignalName will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC SBASSignalName GetSBASSignalName(GNSSSignalType signal_type) {
  return static_cast<SBASSignalName>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> SIGNAL_NAME_SHIFT) &
      ((1 << SIGNAL_NAME_BITS) - 1)));
}

/**
 * @brief The name of a signal from a QZSS satellite.
 *
 * For some purposes, this enum may be used as part of a bitmask. See
 * @ref gnss_enums_to_bitmasks.
 *
 * This needs to be packed into 3 bits so no values above 7 are allowed.
 */
enum class QZSSSignalName : uint8_t {
  L1CA = 0,
  L1C = 1,
  L2C = 2,
  L5 = 3,
  L6 = 4,
};

/**
 * @brief Get a string representation of the @ref QZSSSignalName enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(QZSSSignalName type) {
  switch (type) {
    case QZSSSignalName::L1CA:
      return "L1CA";

    case QZSSSignalName::L1C:
      return "L1C";

    case QZSSSignalName::L2C:
      return "L2C";

    case QZSSSignalName::L5:
      return "L5";

    case QZSSSignalName::L6:
      return "L6";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(QZSSSignalName type) { return to_string(type); }

/**
 * @brief @ref QZSSSignalName stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, QZSSSignalName type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref QZSSSignalName.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(QZSSSignalName type) {
  switch (type) {
    case QZSSSignalName::L1CA:
      return "C/A";

    case QZSSSignalName::L1C:
      return "L1C";

    case QZSSSignalName::L2C:
      return "L2C";

    case QZSSSignalName::L5:
      return "L5";

    case QZSSSignalName::L6:
      return "L6";
  }
  return "Invalid";
}

/**
 * @brief Extract the @ref QZSSSignalName enum value from a
 *        @ref GNSSSignalType.
 *
 * @param signal_type The signal type from which the @ref QZSSSignalName will
 *        be extracted.
 *
 * @return The corresponding enum value.
 */
P1_CONSTEXPR_FUNC QZSSSignalName GetQZSSSignalName(GNSSSignalType signal_type) {
  return static_cast<QZSSSignalName>(static_cast<uint8_t>(
      (static_cast<uint16_t>(signal_type) >> SIGNAL_NAME_SHIFT) &
      ((1 << SIGNAL_NAME_BITS) - 1)));
}

/**
 * @brief Representation of the combination of GNSS constellation, signal type,
 *        and component being tracked (pilot/data).
 *
 * This `enum` is organized as a bitmask, defined as follows:
 * ```
 * { SatelliteType (4b), Reserved (2b), FrequencyBand (4b), Reserved (1b),
 *   *SignalName (3b), GNSSComponent (2b) }
 * ```
 *
 * The `*SignalName` mappings are specific to each @ref SatelliteType. For
 * example, use @ref GPSSignalName for GPS signal definitions.
 *
 * Each enumeration entry uniquely identifies an individual GNSS signal being
 * tracked by the GNSS receiver. For signals that have separate data and pilot
 * components, the entry indicates which component is being tracked.
 */
enum class GNSSSignalType : uint16_t {
  // clang-format off
  UNKNOWN = 0,

  //////////////////////////////////////////////////////////////////////////////
  // GPS
  //////////////////////////////////////////////////////////////////////////////

  // L1 Band

  /// GPS C/A: 4096 (0x1000)
  GPS_L1CA = ToSignalVal(SatelliteType::GPS, FrequencyBand::L1,
                         GPSSignalName::L1CA, GNSSComponent::COMBINED),
  /// GPS L1 P(Y): 4100 (0x1004)
  GPS_L1P = ToSignalVal(SatelliteType::GPS, FrequencyBand::L1,
                        GPSSignalName::L1P, GNSSComponent::COMBINED),
  /// GPS L1C: 4104 (0x1008)
  GPS_L1C = ToSignalVal(SatelliteType::GPS, FrequencyBand::L1,
                        GPSSignalName::L1C, GNSSComponent::COMBINED),
  /// GPS L1C-D (Data): 4105 (0x1009)
  GPS_L1C_D = ToSignalVal(SatelliteType::GPS, FrequencyBand::L1,
                          GPSSignalName::L1C, GNSSComponent::DATA),
  /// GPS L1C-P (Pilot): 4106 (0x100A)
  GPS_L1C_P = ToSignalVal(SatelliteType::GPS, FrequencyBand::L1,
                          GPSSignalName::L1C, GNSSComponent::PILOT),

  // L2 Band

  /// GPS L2C: 4172 (0x104C)
  GPS_L2C = ToSignalVal(SatelliteType::GPS, FrequencyBand::L2,
                        GPSSignalName::L2C, GNSSComponent::COMBINED),
  /// GPS L2C-M (Data): 4173 (0x104D)
  GPS_L2C_M = ToSignalVal(SatelliteType::GPS, FrequencyBand::L2,
                          GPSSignalName::L2C, GNSSComponent::DATA),
  /// GPS L2C-L (Pilot): 4174 (0x104E)
  GPS_L2C_L = ToSignalVal(SatelliteType::GPS, FrequencyBand::L2,
                          GPSSignalName::L2C, GNSSComponent::PILOT),
  /// GPS L2 P(Y): 4176 (0x1050)
  GPS_L2P = ToSignalVal(SatelliteType::GPS, FrequencyBand::L2,
                        GPSSignalName::L2P, GNSSComponent::COMBINED),

  // L5 Band

  /// GPS L5: 4244 (0x1094)
  GPS_L5 = ToSignalVal(SatelliteType::GPS, FrequencyBand::L5,
                       GPSSignalName::L5, GNSSComponent::COMBINED),
  /// GPS L5-I (Data): 4245 (0x1095)
  GPS_L5_I = ToSignalVal(SatelliteType::GPS, FrequencyBand::L5,
                         GPSSignalName::L5, GNSSComponent::DATA),
  /// GPS L5-Q (Pilot): 4246 (0x1096)
  GPS_L5_Q = ToSignalVal(SatelliteType::GPS, FrequencyBand::L5,
                         GPSSignalName::L5, GNSSComponent::PILOT),

  //////////////////////////////////////////////////////////////////////////////
  // GLONASS
  //////////////////////////////////////////////////////////////////////////////

  // L1 Band

  /// GLONASS L1 C/A: 8192 (0x2000)
  GLONASS_L1CA = ToSignalVal(SatelliteType::GLONASS, FrequencyBand::L1,
                             GLONASSSignalName::L1CA, GNSSComponent::COMBINED),
  /// GLONASS L1P: 8196 (0x2004)
  GLONASS_L1P = ToSignalVal(SatelliteType::GLONASS, FrequencyBand::L1,
                            GLONASSSignalName::L1P, GNSSComponent::COMBINED),

  // L2 Band

  /// GLONASS L2 C/A: 8264 (0x2048)
  GLONASS_L2CA = ToSignalVal(SatelliteType::GLONASS, FrequencyBand::L2,
                             GLONASSSignalName::L2CA, GNSSComponent::COMBINED),
  /// GLONASS L2P: 8268 (0x204C)
  GLONASS_L2P = ToSignalVal(SatelliteType::GLONASS, FrequencyBand::L2,
                            GLONASSSignalName::L2P, GNSSComponent::COMBINED),

  //////////////////////////////////////////////////////////////////////////////
  // Galileo
  //////////////////////////////////////////////////////////////////////////////

  // L1 Band

  /// Galileo E1-A: 16384 (0x4000)
  GALILEO_E1A = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L1,
                            GalileoSignalName::E1A, GNSSComponent::COMBINED),
  /// Galileo E1-B/C: 16388 (0x4004)
  GALILEO_E1BC = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L1,
                             GalileoSignalName::E1BC, GNSSComponent::COMBINED),
  /// Galileo E1-B (Data): 16389 (0x4005)
  GALILEO_E1B = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L1,
                            GalileoSignalName::E1BC, GNSSComponent::DATA),
  /// Galileo E1-C (Pilot): 16390 (0x4006)
  GALILEO_E1C = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L1,
                            GalileoSignalName::E1BC, GNSSComponent::PILOT),

  // L2 Band

  /// Galileo E5b: 16460 (0x404C)
  GALILEO_E5B = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L2,
                            GalileoSignalName::E5B, GNSSComponent::COMBINED),
  /// Galileo E5b-I (Data): 16461 (0x404D)
  GALILEO_E5B_I = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L2,
                              GalileoSignalName::E5B, GNSSComponent::DATA),
  /// Galileo E5b-Q (Pilot): 16462 (0x404E)
  GALILEO_E5B_Q = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L2,
                              GalileoSignalName::E5B, GNSSComponent::PILOT),

  // L5 Band

  /// Galileo E5a: 16520 (0x4088)
  GALILEO_E5A = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L5,
                            GalileoSignalName::E5A, GNSSComponent::COMBINED),
  /// Galileo E5a-I (Data): 16521 (0x4089)
  GALILEO_E5A_I = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L5,
                              GalileoSignalName::E5A, GNSSComponent::DATA),
  /// Galileo E5a-Q (Pilot): 16522 (0x408A)
  GALILEO_E5A_Q = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L5,
                              GalileoSignalName::E5A, GNSSComponent::PILOT),

  // L6 Band

  /// Galileo E6-A: 16592 (0x40D0)
  GALILEO_E6A = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L6,
                            GalileoSignalName::E6A, GNSSComponent::COMBINED),
  /// Galileo E6-B/C: 16596 (0x40D4)
  GALILEO_E6BC = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L6,
                             GalileoSignalName::E6BC, GNSSComponent::COMBINED),
  /// Galileo E6-B (Data): 16597 (0x40D5)
  GALILEO_E6B = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L6,
                            GalileoSignalName::E6BC, GNSSComponent::DATA),
  /// Galileo E6-C (Pilot): 16598 (0x40D6)
  GALILEO_E6C = ToSignalVal(SatelliteType::GALILEO, FrequencyBand::L6,
                            GalileoSignalName::E6BC, GNSSComponent::PILOT),

  //////////////////////////////////////////////////////////////////////////////
  // BeiDou
  //////////////////////////////////////////////////////////////////////////////

  // L1 Band

  /// BeiDou B1I: 20480 (0x5000)
  BEIDOU_B1I = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L1,
                           BeiDouSignalName::B1I, GNSSComponent::COMBINED),
  /// BeiDou B1C: 20484 (0x5004)
  BEIDOU_B1C = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L1,
                           BeiDouSignalName::B1C, GNSSComponent::COMBINED),
  /// BeiDou B1C-D (Data): 20485 (0x5005)
  BEIDOU_B1C_D = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L1,
                             BeiDouSignalName::B1C, GNSSComponent::DATA),
  /// BeiDou B1C-P (Pilot): 20486 (0x5006)
  BEIDOU_B1C_P = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L1,
                             BeiDouSignalName::B1C, GNSSComponent::PILOT),

  // L2 Band

  /// BeiDou B2I: 20552 (0x5048)
  BEIDOU_B2I = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L2,
                           BeiDouSignalName::B2I, GNSSComponent::COMBINED),
  /// BeiDou B2b: 20556 (0x504C)
  BEIDOU_B2B = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L2,
                           BeiDouSignalName::B2B, GNSSComponent::COMBINED),

  // L5 Band

  /// BeiDou B2a: 20624 (0x5090)
  BEIDOU_B2A = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L5,
                           BeiDouSignalName::B2A, GNSSComponent::COMBINED),
  /// BeiDou B2a-D (Data): 20625 (0x5091)
  BEIDOU_B2A_D = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L5,
                             BeiDouSignalName::B2A, GNSSComponent::DATA),
  /// BeiDou B2a-P (Pilot): 20626 (0x5092)
  BEIDOU_B2A_P = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L5,
                             BeiDouSignalName::B2A, GNSSComponent::PILOT),

  // L6 Band

  /// BeiDou B3I: 20692 (0x50D4)
  BEIDOU_B3I = ToSignalVal(SatelliteType::BEIDOU, FrequencyBand::L6,
                           BeiDouSignalName::B3I, GNSSComponent::COMBINED),

  //////////////////////////////////////////////////////////////////////////////
  // QZSS
  //////////////////////////////////////////////////////////////////////////////

  // L1 Band

  /// QZSS C/A: 24576 (0x6000)
  QZSS_L1CA = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L1,
                          QZSSSignalName::L1CA, GNSSComponent::COMBINED),
  /// QZSS L1C: 24580 (0x6004)
  QZSS_L1C = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L1,
                         QZSSSignalName::L1C, GNSSComponent::COMBINED),
  /// QZSS L1C-D (Data): 24581 (0x6005)
  QZSS_L1C_D = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L1,
                           QZSSSignalName::L1C, GNSSComponent::DATA),
  /// QZSS L1C-P (Pilot): 24582 (0x6006)
  QZSS_L1C_P = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L1,
                           QZSSSignalName::L1C, GNSSComponent::PILOT),

  // L2 Band

  /// QZSS L2C: 24648 (0x6048)
  QZSS_L2C = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L2,
                         QZSSSignalName::L2C, GNSSComponent::COMBINED),
  /// QZSS L2C-M (Data): 24649 (0x6049)
  QZSS_L2C_M = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L2,
                           QZSSSignalName::L2C, GNSSComponent::DATA),
  /// QZSS L2C-L (Pilot): 24650 (0x604A)
  QZSS_L2C_L = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L2,
                           QZSSSignalName::L2C, GNSSComponent::PILOT),
  /// QZSS L6: 24656 (0x6050)
  QZSS_L6 = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L2,
                        QZSSSignalName::L6, GNSSComponent::COMBINED),
  /// QZSS L6-M (Data): 24657 (0x6051)
  QZSS_L6_M = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L2,
                          QZSSSignalName::L6, GNSSComponent::DATA),
  /// QZSS L6-L (Pilot): 24658 (0x6052)
  QZSS_L6_L = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L2,
                          QZSSSignalName::L6, GNSSComponent::PILOT),

  // L5 Band

  /// QZSS L5: 24716 (0x608C)
  QZSS_L5 = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L5,
                        QZSSSignalName::L5, GNSSComponent::COMBINED),
  /// QZSS L5-I (Data): 24717 (0x608D)
  QZSS_L5_I = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L5,
                          QZSSSignalName::L5, GNSSComponent::DATA),
  /// QZSS L5-Q (Pilot): 24718 (0x608E)
  QZSS_L5_Q = ToSignalVal(SatelliteType::QZSS, FrequencyBand::L5,
                          QZSSSignalName::L5, GNSSComponent::PILOT),

  //////////////////////////////////////////////////////////////////////////////
  // SBAS
  //////////////////////////////////////////////////////////////////////////////

  // L1 Band

  /// SBAS C/A: 32768 (0x8000)
  SBAS_L1CA = ToSignalVal(SatelliteType::SBAS, FrequencyBand::L1,
                          SBASSignalName::L1CA, GNSSComponent::COMBINED),

  // L5 Band

  /// SBAS L5: 32900 (0x8084)
  SBAS_L5 = ToSignalVal(SatelliteType::SBAS, FrequencyBand::L5,
                        SBASSignalName::L5, GNSSComponent::COMBINED),
  /// SBAS L5-I (Data): 32901 (0x8085)
  SBAS_L5_I = ToSignalVal(SatelliteType::SBAS, FrequencyBand::L5,
                          SBASSignalName::L5, GNSSComponent::DATA),
  /// SBAS L5-Q (Pilot): 32902 (0x8086)
  SBAS_L5_Q = ToSignalVal(SatelliteType::SBAS, FrequencyBand::L5,
                          SBASSignalName::L5, GNSSComponent::PILOT),
  // clang-format on
};

/**
 * @brief Get a string representation of the @ref GNSSSignalType enum value.
 *
 * @param type The enum to get the string name for.
 *
 * @return The corresponding string name.
 */
P1_CONSTEXPR_FUNC const char* to_string(GNSSSignalType type) {
  switch (type) {
    case GNSSSignalType::GPS_L1CA:
      return "GPS_L1CA";

    case GNSSSignalType::GPS_L1P:
      return "GPS_L1P";

    case GNSSSignalType::GPS_L1C:
      return "GPS_L1C";

    case GNSSSignalType::GPS_L1C_D:
      return "GPS_L1C_D";

    case GNSSSignalType::GPS_L1C_P:
      return "GPS_L1C_P";

    case GNSSSignalType::GPS_L2C:
      return "GPS_L2C";

    case GNSSSignalType::GPS_L2C_M:
      return "GPS_L2C_M";

    case GNSSSignalType::GPS_L2C_L:
      return "GPS_L2C_L";

    case GNSSSignalType::GPS_L2P:
      return "GPS_L2P";

    case GNSSSignalType::GPS_L5:
      return "GPS_L5";

    case GNSSSignalType::GPS_L5_I:
      return "GPS_L5_I";

    case GNSSSignalType::GPS_L5_Q:
      return "GPS_L5_Q";

    case GNSSSignalType::GLONASS_L1CA:
      return "GLONASS_L1CA";

    case GNSSSignalType::GLONASS_L1P:
      return "GLONASS_L1P";

    case GNSSSignalType::GLONASS_L2CA:
      return "GLONASS_L2CA";

    case GNSSSignalType::GLONASS_L2P:
      return "GLONASS_L2P";

    case GNSSSignalType::GALILEO_E1A:
      return "GALILEO_E1A";

    case GNSSSignalType::GALILEO_E1BC:
      return "GALILEO_E1BC";

    case GNSSSignalType::GALILEO_E1B:
      return "GALILEO_E1B";

    case GNSSSignalType::GALILEO_E1C:
      return "GALILEO_E1C";

    case GNSSSignalType::GALILEO_E5B:
      return "GALILEO_E5B";

    case GNSSSignalType::GALILEO_E5B_I:
      return "GALILEO_E5B_I";

    case GNSSSignalType::GALILEO_E5B_Q:
      return "GALILEO_E5B_Q";

    case GNSSSignalType::GALILEO_E5A:
      return "GALILEO_E5A";

    case GNSSSignalType::GALILEO_E5A_I:
      return "GALILEO_E5A_I";

    case GNSSSignalType::GALILEO_E5A_Q:
      return "GALILEO_E5A_Q";

    case GNSSSignalType::GALILEO_E6A:
      return "GALILEO_E6A";

    case GNSSSignalType::GALILEO_E6BC:
      return "GALILEO_E6BC";

    case GNSSSignalType::GALILEO_E6B:
      return "GALILEO_E6B";

    case GNSSSignalType::GALILEO_E6C:
      return "GALILEO_E6C";

    case GNSSSignalType::BEIDOU_B1I:
      return "BEIDOU_B1I";

    case GNSSSignalType::BEIDOU_B1C:
      return "BEIDOU_B1C";

    case GNSSSignalType::BEIDOU_B1C_D:
      return "BEIDOU_B1C_D";

    case GNSSSignalType::BEIDOU_B1C_P:
      return "BEIDOU_B1C_P";

    case GNSSSignalType::BEIDOU_B2I:
      return "BEIDOU_B2I";

    case GNSSSignalType::BEIDOU_B2B:
      return "BEIDOU_B2B";

    case GNSSSignalType::BEIDOU_B2A:
      return "BEIDOU_B2A";

    case GNSSSignalType::BEIDOU_B2A_D:
      return "BEIDOU_B2A_D";

    case GNSSSignalType::BEIDOU_B2A_P:
      return "BEIDOU_B2A_P";

    case GNSSSignalType::BEIDOU_B3I:
      return "BEIDOU_B3I";

    case GNSSSignalType::SBAS_L1CA:
      return "SBAS_L1CA";

    case GNSSSignalType::SBAS_L5:
      return "SBAS_L5";

    case GNSSSignalType::SBAS_L5_I:
      return "SBAS_L5_I";

    case GNSSSignalType::SBAS_L5_Q:
      return "SBAS_L5_Q";

    case GNSSSignalType::QZSS_L1CA:
      return "QZSS_L1CA";

    case GNSSSignalType::QZSS_L1C:
      return "QZSS_L1C";

    case GNSSSignalType::QZSS_L1C_D:
      return "QZSS_L1C_D";

    case GNSSSignalType::QZSS_L1C_P:
      return "QZSS_L1C_P";

    case GNSSSignalType::QZSS_L2C:
      return "QZSS_L2C";

    case GNSSSignalType::QZSS_L2C_M:
      return "QZSS_L2C_M";

    case GNSSSignalType::QZSS_L2C_L:
      return "QZSS_L2C_L";

    case GNSSSignalType::QZSS_L5:
      return "QZSS_L5";

    case GNSSSignalType::QZSS_L5_I:
      return "QZSS_L5_I";

    case GNSSSignalType::QZSS_L5_Q:
      return "QZSS_L5_Q";

    case GNSSSignalType::QZSS_L6:
      return "QZSS_L6";

    case GNSSSignalType::QZSS_L6_M:
      return "QZSS_L6_M";

    case GNSSSignalType::QZSS_L6_L:
      return "QZSS_L6_L";

    case GNSSSignalType::UNKNOWN:
      return "UNKNOWN";
  }
  return "INVALID";
}

/**
 * @copydoc to_string()
 */
inline const char* ToString(GNSSSignalType type) { return to_string(type); }

/**
 * @brief @ref GNSSSignalType stream operator.
 */
inline p1_ostream& operator<<(p1_ostream& stream, GNSSSignalType type) {
  stream << to_string(type) << " (" << (int)type << ")";
  return stream;
}

/**
 * @brief Get a human-friendly string for the specified @ref GNSSSignalType.
 *
 * @param type The enum to get the string for.
 *
 * @return The corresponding string.
 */
P1_CONSTEXPR_FUNC const char* ToPrettyString(GNSSSignalType type) {
  switch (type) {
    case GNSSSignalType::GPS_L1CA:
      return "GPS C/A";

    case GNSSSignalType::GPS_L1P:
      return "GPS L1 P(Y)";

    case GNSSSignalType::GPS_L1C:
      return "GPS L1C";

    case GNSSSignalType::GPS_L1C_D:
      return "GPS L1C-D (Data)";

    case GNSSSignalType::GPS_L1C_P:
      return "GPS L1C-P (Pilot)";

    case GNSSSignalType::GPS_L2C:
      return "GPS L2C";

    case GNSSSignalType::GPS_L2C_M:
      return "GPS L2C-M (Data)";

    case GNSSSignalType::GPS_L2C_L:
      return "GPS L2C-L (Pilot)";

    case GNSSSignalType::GPS_L2P:
      return "GPS L2 P(Y)";

    case GNSSSignalType::GPS_L5:
      return "GPS L5";

    case GNSSSignalType::GPS_L5_I:
      return "GPS L5-I (Data)";

    case GNSSSignalType::GPS_L5_Q:
      return "GPS L5-Q (Pilot)";

    case GNSSSignalType::GLONASS_L1CA:
      return "GLONASS L1 C/A";

    case GNSSSignalType::GLONASS_L1P:
      return "GLONASS L1P";

    case GNSSSignalType::GLONASS_L2CA:
      return "GLONASS L2 C/A";

    case GNSSSignalType::GLONASS_L2P:
      return "GLONASS L2P";

    case GNSSSignalType::GALILEO_E1A:
      return "Galileo E1-A";

    case GNSSSignalType::GALILEO_E1BC:
      return "Galileo E1-B/C";

    case GNSSSignalType::GALILEO_E1B:
      return "Galileo E1-B (Data)";

    case GNSSSignalType::GALILEO_E1C:
      return "Galileo E1-C (Pilot)";

    case GNSSSignalType::GALILEO_E5B:
      return "Galileo E5b";

    case GNSSSignalType::GALILEO_E5B_I:
      return "Galileo E5b-I (Data)";

    case GNSSSignalType::GALILEO_E5B_Q:
      return "Galileo E5b-Q (Pilot)";

    case GNSSSignalType::GALILEO_E5A:
      return "Galileo E5a";

    case GNSSSignalType::GALILEO_E5A_I:
      return "Galileo E5a-I (Data)";

    case GNSSSignalType::GALILEO_E5A_Q:
      return "Galileo E5a-Q (Pilot)";

    case GNSSSignalType::GALILEO_E6A:
      return "Galileo E6-A";

    case GNSSSignalType::GALILEO_E6BC:
      return "Galileo E6-B/C";

    case GNSSSignalType::GALILEO_E6B:
      return "Galileo E6-B (Data)";

    case GNSSSignalType::GALILEO_E6C:
      return "Galileo E6-C (Pilot)";

    case GNSSSignalType::BEIDOU_B1I:
      return "BeiDou B1I";

    case GNSSSignalType::BEIDOU_B1C:
      return "BeiDou B1C";

    case GNSSSignalType::BEIDOU_B1C_D:
      return "BeiDou B1C-D (Data)";

    case GNSSSignalType::BEIDOU_B1C_P:
      return "BeiDou B1C-P (Pilot)";

    case GNSSSignalType::BEIDOU_B2I:
      return "BeiDou B2I";

    case GNSSSignalType::BEIDOU_B2B:
      return "BeiDou B2b";

    case GNSSSignalType::BEIDOU_B2A:
      return "BeiDou B2a";

    case GNSSSignalType::BEIDOU_B2A_D:
      return "BeiDou B2a-D (Data)";

    case GNSSSignalType::BEIDOU_B2A_P:
      return "BeiDou B2a-P (Pilot)";

    case GNSSSignalType::BEIDOU_B3I:
      return "BeiDou B3I";

    case GNSSSignalType::SBAS_L1CA:
      return "SBAS C/A";

    case GNSSSignalType::SBAS_L5:
      return "SBAS L5";

    case GNSSSignalType::SBAS_L5_I:
      return "SBAS L5-I (Data)";

    case GNSSSignalType::SBAS_L5_Q:
      return "SBAS L5-Q (Pilot)";

    case GNSSSignalType::QZSS_L1CA:
      return "QZSS C/A";

    case GNSSSignalType::QZSS_L1C:
      return "QZSS L1C";

    case GNSSSignalType::QZSS_L1C_D:
      return "QZSS L1C-D (Data)";

    case GNSSSignalType::QZSS_L1C_P:
      return "QZSS L1C-P (Pilot)";

    case GNSSSignalType::QZSS_L2C:
      return "QZSS L2C";

    case GNSSSignalType::QZSS_L2C_M:
      return "QZSS L2C-M (Data)";

    case GNSSSignalType::QZSS_L2C_L:
      return "QZSS L2C-L (Pilot)";

    case GNSSSignalType::QZSS_L5:
      return "QZSS L5";

    case GNSSSignalType::QZSS_L5_I:
      return "QZSS L5-I (Data)";

    case GNSSSignalType::QZSS_L5_Q:
      return "QZSS L5-Q (Pilot)";

    case GNSSSignalType::QZSS_L6:
      return "QZSS L6";

    case GNSSSignalType::QZSS_L6_M:
      return "QZSS L6-M (Data)";

    case GNSSSignalType::QZSS_L6_L:
      return "QZSS L6-L (Pilot)";

    case GNSSSignalType::UNKNOWN:
      return "Unknown";
  }
  return "Invalid";
}

// < Stop Autogenerated Types (See python/fusion_engine_client/messages/signal_def_gen.py)

/**
 * @defgroup sat_type_masks @ref SatelliteType Bitmask Support
 * @ingroup config_types
 *
 * These values can be used to specify a bitmask for controlling enabled GNSS
 * constellations. The bit locations are equal to the values set by @ref
 * SatelliteType for each constellation.
 *
 * For example, the mask 0x32 enables GPS, Galileo, and BeiDou. You can create
 * that mask with the `SATELLITE_TYPE_MASK_*` constants:
 * ```cpp
 * uint32_t mask = SATELLITE_TYPE_MASK_GPS | SATELLITE_TYPE_MASK_GALILEO |
 *                 SATELLITE_TYPE_MASK_BEIDOU;
 * ```
 *
 * or by calling the @ref ToBitMask(SatelliteType) helper function:
 * ```cpp
 * uint32_t mask = ToBitMask(SatelliteType::GPS, SatelliteType::GALILEO,
 *                           SatelliteType::BEIDOU);
 * ```
 *
 * @{
 */

static constexpr uint32_t SATELLITE_TYPE_MASK_GPS =
    (1UL << static_cast<uint8_t>(SatelliteType::GPS));
static constexpr uint32_t SATELLITE_TYPE_MASK_GLONASS =
    (1UL << static_cast<uint8_t>(SatelliteType::GLONASS));
static constexpr uint32_t SATELLITE_TYPE_MASK_LEO =
    (1UL << static_cast<uint8_t>(SatelliteType::LEO));
static constexpr uint32_t SATELLITE_TYPE_MASK_GALILEO =
    (1UL << static_cast<uint8_t>(SatelliteType::GALILEO));
static constexpr uint32_t SATELLITE_TYPE_MASK_BEIDOU =
    (1UL << static_cast<uint8_t>(SatelliteType::BEIDOU));
static constexpr uint32_t SATELLITE_TYPE_MASK_QZSS =
    (1UL << static_cast<uint8_t>(SatelliteType::QZSS));
static constexpr uint32_t SATELLITE_TYPE_MASK_MIXED =
    (1UL << static_cast<uint8_t>(SatelliteType::MIXED));
static constexpr uint32_t SATELLITE_TYPE_MASK_SBAS =
    (1UL << static_cast<uint8_t>(SatelliteType::SBAS));
static constexpr uint32_t SATELLITE_TYPE_MASK_IRNSS =
    (1UL << static_cast<uint8_t>(SatelliteType::IRNSS));

static constexpr uint32_t SATELLITE_TYPE_MASK_ALL = 0xFFFFFFFF;

/**
 * @brief Convert a @ref SatelliteType to a corresponding constellation control
 *        bitmask value.
 *
 * For example:
 *
 * ```cpp
 * uint32_t mask = ToBitMask(SatelliteType::GPS);
 * ```
 *
 * generates the following bitmask:
 *
 * ```cpp
 * uint32_t mask = (1UL << static_cast<uint8_t>(SatelliteType::GPS));
 * ```
 *
 * @param type The desired constellation.
 *
 * @return The corresponding bitmask.
 */
P1_CONSTEXPR_FUNC uint32_t ToBitMask(SatelliteType type) {
  return (1U << (static_cast<uint8_t>(type)));
}

/**
 * @brief Convert two or more @ref SatelliteType values to a bitmask.
 *
 * For example:
 *
 * ```cpp
 * uint32_t mask = ToBitMask(SatelliteType::GPS, SatelliteType::GALILEO,
 *                           SatelliteType::BEIDOU);
 * ```
 *
 * generates the following bitmask:
 *
 * ```cpp
 * uint32_t mask = (1UL << static_cast<uint8_t>(SatelliteType::GPS)) |
 *                 (1UL << static_cast<uint8_t>(SatelliteType::GALILEO)) |
 *                 (1UL << static_cast<uint8_t>(SatelliteType::BEIDOU));
 * ```
 *
 * @tparam Args The type of the `others` values (@ref SatelliteType)
 * @param first The first value.
 * @param others One or more additional values.
 *
 * @return The corresponding bitmask.
 */
template <typename... Args>
P1_CONSTEXPR_FUNC uint32_t ToBitMask(SatelliteType first, Args... others) {
  return ToBitMask(first) | ToBitMask(others...);
}

/** @} */

/**
 * @defgroup freq_band_masks @ref FrequencyBand Bitmask Support
 * @ingroup config_types
 *
 * These values can be used to specify a bitmask for controlling enabled GNSS
 * frequency bands. The bit locations are equal to the values set by @ref
 * FrequencyBand.
 *
 * For example, the mask 0x22 enables L1 and L5. You can create that mask with
 * the `FREQUENCY_BAND_MASK_*` constants:
 * ```cpp
 * uint32_t mask = FREQUENCY_BAND_MASK_L1 | FREQUENCY_BAND_MASK_L5;
 * ```
 *
 * or by calling the @ref ToBitMask(FrequencyBand) helper function:
 * ```cpp
 * uint32_t mask = ToBitMask(FrequencyBand::L1, FrequencyBand::L5);
 * ```
 *
 * @{
 */

static constexpr uint32_t FREQUENCY_BAND_MASK_L1 =
    (1UL << static_cast<uint8_t>(FrequencyBand::L1));
static constexpr uint32_t FREQUENCY_BAND_MASK_L2 =
    (1UL << static_cast<uint8_t>(FrequencyBand::L2));
static constexpr uint32_t FREQUENCY_BAND_MASK_L5 =
    (1UL << static_cast<uint8_t>(FrequencyBand::L5));
static constexpr uint32_t FREQUENCY_BAND_MASK_L6 =
    (1UL << static_cast<uint8_t>(FrequencyBand::L6));

static constexpr uint32_t FREQUENCY_BAND_MASK_ALL = 0xFFFFFFFF;

/**
 * @brief Convert a @ref FrequencyBand to a corresponding frequency control
 *        bitmask value.
 *
 * For example:
 *
 * ```cpp
 * uint32_t mask = ToBitMask(FrequencyBand::L1);
 * ```
 *
 * generates the following bitmask:
 *
 * ```cpp
 * uint32_t mask = (1UL << static_cast<uint8_t>(FrequencyBand::L1));
 * ```
 *
 * @param type The desired frequency band.
 *
 * @return The corresponding bitmask.
 */
P1_CONSTEXPR_FUNC uint32_t ToBitMask(FrequencyBand type) {
  return (1U << (static_cast<uint8_t>(type)));
}

/**
 * @brief Convert two or more @ref FrequencyBand values to a bitmask.
 *
 * For example:
 *
 * ```cpp
 * uint32_t mask = ToBitMask(FrequencyBand::L1, FrequencyBand::L5);
 * ```
 *
 * generates the following bitmask:
 *
 * ```cpp
 * uint32_t mask = (1UL << static_cast<uint8_t>(FrequencyBand::L1)) |
 *                 (1UL << static_cast<uint8_t>(FrequencyBand::L5));
 * ```
 *
 * @tparam Args The type of the `others` values (@ref FrequencyBand)
 * @param first The first value.
 * @param others One or more additional values.
 *
 * @return The corresponding bitmask.
 */
template <typename... Args>
P1_CONSTEXPR_FUNC uint32_t ToBitMask(FrequencyBand first, Args... others) {
  return ToBitMask(first) | ToBitMask(others...);
}

/** @} */

/** @} */

} // namespace messages
} // namespace fusion_engine
} // namespace point_one
